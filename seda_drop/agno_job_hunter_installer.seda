#!/usr/bin/env python3
"""
# üì¶ Agno Job Hunter v2.0 - SEDA Installer

This is a **Self-Extracting Document Archive (SEDA)** for the Agno Job Hunter project.
It contains the full source code for the Agent Team, including the new Application Tracking logic.

## üöÄ Quick Start

To extract the project files, run this script:

```bash
python agno_job_hunter_installer.py
```

## üìÑ Included Files

- `team.py`: Main Orchestrator
- `requirements.txt`: Dependencies
- `tools/google_sheets.py`: **NEW** Bi-directional linking & Application Tracking
- `tools/email_tools.py`: **NEW** Communication & Inbox monitoring
- `tools/job_spy_tool.py`: Job Scraping (JobSpy)
- `tools/__init__.py`: Package marker

---
**Technical Details:**
This file is a valid Python script containing a payload of source code.
When executed, it recreates the directory structure in your current folder.
"""
import os
import base64
import sys

# --- PAYLOAD DATA ---
PAYLOAD = {
    'requirements.txt': 'agno\nopenai\ngspread\npython-jobspy\npandas',

    'team.py': r'''import os
from agno.agent import Agent
from agno.team import Team
from agno.models.openai import OpenAIChat
from tools.google_sheets import GoogleSheetsTools
from tools.job_spy_tool import JobSpyTools
from tools.email_tools import EmailTools

# --- Config ---
# Ensure env vars: EMAIL_USER, EMAIL_APP_PASS
email_user = os.getenv("EMAIL_USER")
email_pass = os.getenv("EMAIL_APP_PASS")

# --- Init Tools ---
# 'spreadsheet_name' must match your Google Sheet name exactly
gs_tools = GoogleSheetsTools(credentials_path="credentials.json", spreadsheet_name="Job_Hunt_2025")
spy_tools = JobSpyTools()
comm_tools = EmailTools(email_address=email_user, app_password=email_pass)

# 1. Job Scout (Learning & Finding)
job_finder = Agent(
    name="Job Scout",
    role="Source Jobs",
    model=OpenAIChat(id="gpt-4o"),
    tools=[spy_tools, gs_tools],
    instructions=[
        "1. Call `get_user_preferences` to understand what to filter out.",
        "2. Call `find_jobs` with `results_wanted=20`.",
        "3. Filter results based on preferences.",
        "4. Call `add_job` for the best matches."
    ],
)

# 2. Resume Writer (Tailoring)
resume_writer = Agent(
    name="Resume Writer",
    role="Tailor Applications",
    model=OpenAIChat(id="gpt-4o"),
    tools=[gs_tools],
    instructions=[
        "Monitor 'Jobs' sheet for 'New' status.",
        "Create tailored resume content (simulated).",
        "Update 'Jobs' sheet notes with the tailored summary."
    ],
)

# 3. Comms Manager (Tracking & Sending)
comm_agent = Agent(
    name="Comms Manager",
    role="Manage Correspondence",
    model=OpenAIChat(id="gpt-4o"),
    tools=[comm_tools, gs_tools],
    instructions=[
        "SENDING APPLICATIONS:",
        "1. When instructed to apply, draft/send the email.",
        "2. CRITICAL: After sending, call `promote_to_application(job_url, 'Applied')`.",
        "   This moves the job to the 'Applications' tracking sheet.",

        "CHECKING INBOX:",
        "Search for keywords (Interview, LinkedIn).",
        "Update 'Applications' sheet status if a reply is found."
    ],
    markdown=True
)

# 4. Team Leader
headhunter_team = Team(
    name="Headhunter Manager",
    agents=[job_finder, resume_writer, comm_agent],
    model=OpenAIChat(id="gpt-4o"),
    instructions=[
        "You manage a job hunting agency.",
        "Coordinate the flow: Scout -> Writer -> Comms.",
        "Ensure Comms Manager uses the new `promote_to_application` tool when applications are sent."
    ]
)

if __name__ == "__main__":
    print("--- Starting Job Hunter v2.0 ---")
    headhunter_team.print_response(
        "Find 5 Python jobs in Austin, filter by my preferences, and apply to the best one.",
        stream=True
    )
''',

    'tools/__init__.py': '',

    'tools/email_tools.py': r'''import smtplib
import imaplib
import email
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import decode_header
from agno.tools import Toolkit
from agno.utils.log import logger

class EmailTools(Toolkit):
    def __init__(self, email_address: str, app_password: str, imap_server="imap.gmail.com", smtp_server="smtp.gmail.com"):
        super().__init__(name="email_tools")
        self.email_address = email_address
        self.password = app_password
        self.imap_server = imap_server
        self.smtp_server = smtp_server
        self.register_ops([self.send_message, self.search_messages])

    def send_message(self, to_email: str, subject: str, body: str):
        try:
            msg = MIMEMultipart()
            msg['From'] = self.email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))

            with smtplib.SMTP_SSL(self.smtp_server, 465) as server:
                server.login(self.email_address, self.password)
                server.send_message(msg)
            return f"Email sent to {to_email}"
        except Exception as e:
            return f"Error sending email: {e}"

    def search_messages(self, query: str = "UNSEEN", limit: int = 5):
        try:
            mail = imaplib.IMAP4_SSL(self.imap_server)
            mail.login(self.email_address, self.password)
            mail.select("inbox")
            status, messages = mail.search(None, query)
            if status != "OK": return "No messages."

            results = []
            for e_id in messages[0].split()[-limit:]:
                _, msg_data = mail.fetch(e_id, "(RFC822)")
                for response_part in msg_data:
                    if isinstance(response_part, tuple):
                        msg = email.message_from_bytes(response_part[1])
                        subject = decode_header(msg["Subject"])[0][0]
                        if isinstance(subject, bytes): subject = subject.decode()
                        results.append(f"Subject: {subject}")
            return results
        except Exception as e:
            return f"Error fetching emails: {e}"
''',

    'tools/google_sheets.py': r'''import json
import gspread
from agno.tools import Toolkit
from agno.utils.log import logger
from datetime import datetime

class GoogleSheetsTools(Toolkit):
    def __init__(self, credentials_path: str, spreadsheet_name: str):
        super().__init__(name="google_sheets_tools")
        self.credentials_path = credentials_path
        self.spreadsheet_name = spreadsheet_name
        self.gc = None
        self.sh = None
        self.jobs_sheet = None
        self.apps_sheet = None
        self._authenticate()

        # Register the tools the Agent can access
        self.register_ops([
            self.add_job,
            self.get_new_jobs,
            self.get_user_preferences,
            self.promote_to_application
        ])

    def _authenticate(self):
        """Internal helper to auth with Google"""
        try:
            self.gc = gspread.service_account(filename=self.credentials_path)
            self.sh = self.gc.open(self.spreadsheet_name)

            # Initialize Worksheets
            # Ensure 'Jobs' sheet exists (usually Sheet1)
            try:
                self.jobs_sheet = self.sh.worksheet("Jobs")
            except:
                # Fallback if renamed or default
                self.jobs_sheet = self.sh.sheet1
                self.jobs_sheet.update_title("Jobs")

            # Ensure 'Applications' sheet exists
            try:
                self.apps_sheet = self.sh.worksheet("Applications")
            except:
                self.apps_sheet = self.sh.add_worksheet(title="Applications", rows=100, cols=10)
                # Add Headers
                self.apps_sheet.append_row(["Date Applied", "Company", "Role", "Status", "Link to Job", "Notes"])

            logger.info(f"Connected to Sheets: Jobs ({self.jobs_sheet.id}), Applications ({self.apps_sheet.id})")
        except Exception as e:
            logger.error(f"Failed to authenticate with Google Sheets: {e}")

    def add_job(self, company: str, role: str, url: str, location: str = "Remote"):
        """Adds a new job row to the 'Jobs' sheet."""
        try:
            date_found = datetime.now().strftime("%Y-%m-%d")

            # Deduplication
            try:
                cell = self.jobs_sheet.find(url)
                if cell:
                    return f"Job already exists at row {cell.row}"
            except gspread.exceptions.CellNotFound:
                pass

            # Columns: Date, Company, Role, Location, URL, Status, Notes, User Rating
            self.jobs_sheet.append_row([date_found, company, role, location, url, "New", "", ""])
            return f"Successfully added {role} at {company}."
        except Exception as e:
            return f"Error adding job: {e}"

    def get_new_jobs(self):
        """Retrieves jobs with status 'New' from 'Jobs' sheet."""
        try:
            all_records = self.jobs_sheet.get_all_records()
            new_jobs = [job for job in all_records if job.get('Status') == 'New']
            return json.dumps(new_jobs)
        except Exception as e:
            return f"Error retrieving jobs: {e}"

    def get_user_preferences(self):
        """Retrieves User Ratings for the learning loop."""
        try:
            all_records = self.jobs_sheet.get_all_records()
            rated_jobs = [
                {
                    "Role": job.get("Role"),
                    "Company": job.get("Company"),
                    "Rating": job.get("User Rating")
                }
                for job in all_records
                if str(job.get("User Rating", "")).strip() != ""
            ]
            return json.dumps(rated_jobs) if rated_jobs else "No user ratings found yet."
        except Exception as e:
            return f"Error retrieving preferences: {e}"

    def promote_to_application(self, job_url: str, status: str = "Applied"):
        """
        Promotes a job from the 'Jobs' sheet to the 'Applications' sheet.
        Creates BI-DIRECTIONAL LINKS between the two rows for easy navigation.
        """
        try:
            # 1. Find the Job in the main list
            try:
                job_cell = self.jobs_sheet.find(job_url)
                job_row_idx = job_cell.row
            except gspread.exceptions.CellNotFound:
                return "Job URL not found in Jobs sheet."

            # 2. Get Job Details (Assumes Col 2=Company, Col 3=Role)
            company = self.jobs_sheet.cell(job_row_idx, 2).value
            role = self.jobs_sheet.cell(job_row_idx, 3).value
            date_applied = datetime.now().strftime("%Y-%m-%d")

            # 3. Add to Applications Sheet
            # We add a placeholder for the link first
            self.apps_sheet.append_row([date_applied, company, role, status, "Linking...", ""])

            # Get the row index of the new application entry
            # (It's the last row since we just appended)
            app_row_idx = len(self.apps_sheet.get_all_values())

            # 4. Create Hyperlinks
            # Formula syntax: =HYPERLINK("#gid=SHEET_ID&range=A1", "Label")

            # Link from Apps -> Jobs
            job_gid = self.jobs_sheet.id
            link_to_job = f'=HYPERLINK("#gid={job_gid}&range=A{job_row_idx}", "View Listing")'
            self.apps_sheet.update_cell(app_row_idx, 5, link_to_job) # Col 5 is 'Link to Job'

            # Link from Jobs -> Apps
            app_gid = self.apps_sheet.id
            link_to_app = f'=HYPERLINK("#gid={app_gid}&range=A{app_row_idx}", "TRACKED: {status}")'
            self.jobs_sheet.update_cell(job_row_idx, 6, link_to_app) # Col 6 is 'Status'

            return f"Promoted {role} at {company} to Applications sheet (Row {app_row_idx}). Links created."

        except Exception as e:
            logger.error(f"Failed to promote application: {e}")
            return f"Error promoting application: {e}"
''',

    'tools/job_spy_tool.py': r'''from agno.tools import Toolkit
from agno.utils.log import logger
import pandas as pd
from jobspy import scrape_jobs

class JobSpyTools(Toolkit):
    def __init__(self):
        super().__init__(name="job_spy_tools")
        self.register_ops([self.find_jobs])

    def find_jobs(self, search_term: str, location: str = "Remote", results_wanted: int = 10):
        """
        Searches for jobs on LinkedIn, Indeed, and Glassdoor using JobSpy.
        """
        logger.info(f"Searching for {results_wanted} '{search_term}' jobs in {location}...")
        try:
            jobs_df = scrape_jobs(
                site_name=["linkedin", "indeed", "glassdoor"],
                search_term=search_term,
                location=location,
                results_wanted=results_wanted,
                country_watchlist=["US"],
                hours_old=72
            )

            if jobs_df.empty:
                return "No jobs found."

            formatted_jobs = []
            for _, row in jobs_df.iterrows():
                formatted_jobs.append({
                    "Company": row.get('company'),
                    "Role": row.get('title'),
                    "Location": row.get('location'),
                    "URL": row.get('job_url'),
                    "Site": row.get('site')
                })

            return formatted_jobs
        except Exception as e:
            logger.error(f"JobSpy failed: {e}")
            return f"Error during job search: {e}"
''',
}

# --- EXTRACTOR ENGINE ---
def extract_payload():
    print(f"üí• Self-Exploding SEDA Archive: {os.path.basename(__file__)}")
    print("   Extracting Agno Job Hunter v2.0...")

    for filepath, content in PAYLOAD.items():
        # Determine destination
        dest_path = os.path.join(os.getcwd(), filepath)
        directory = os.path.dirname(dest_path)

        # Create directories
        if directory:
            os.makedirs(directory, exist_ok=True)

        # Write file
        try:
            # If content is bytes (binary), write directly
            if isinstance(content, bytes):
                with open(dest_path, 'wb') as f:
                    f.write(content)
            # If content is string (text or base64 representation), handle accordingly
            elif isinstance(content, str):
                 # Heuristic: If it looks like a text file, try writing as text
                 try:
                     # For this project, all files are text, but we keep structure
                     if filepath.endswith(('.png', '.jpg', '.ico')):
                         with open(dest_path, 'wb') as f:
                            f.write(base64.b64decode(content))
                     else:
                         with open(dest_path, 'w', encoding='utf-8') as f:
                            f.write(content)
                 except Exception:
                     with open(dest_path, 'w', encoding='utf-8') as f:
                        f.write(content)

            print(f"   ‚úÖ Extracted: {filepath}")
        except Exception as e:
            print(f"   ‚ùå Error extracting {filepath}: {e}")

    print("\n‚ú® Explosion complete! Run 'python team.py' to start. ‚ú®")

if __name__ == "__main__":
    extract_payload()
